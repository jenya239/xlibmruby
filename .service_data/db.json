{
  "src/core/container.cpp": {
    "modified_time": "2025-02-13 10:10:37 +0400",
    "hash": "0105aaed813cc2d4f25b13b5259304bb3e7b63a7024f840564bd62f9412f0690",
    "description": "Файл `container.cpp` содержит пустую реализацию, так как все методы шаблонные и определены в заголовочном файле."
  },
  "src/core/container.hpp": {
    "modified_time": "2025-02-13 10:18:44 +0400",
    "hash": "c1e52fa7a4ad2e7142a1426631a4dde61ac458e4e4adffa61f18b730e035f261",
    "description": "Файл `container.hpp` содержит класс `Container`, который предоставляет функционал для регистрации и разрешения синглтонов. Класс содержит методы `register_singleton` для регистрации синглтона и `resolve` для получения экземпляра синглтона по типу. Логика работы заключается в хранении фабричных функций для создания синглтонов и их последующем вызове при разрешении. В случае отсутствия зарегистрированного сервиса генерируется исключение."
  },
  "src/interfaces/iruby_service.hpp": {
    "modified_time": "2025-02-13 04:40:54 +0400",
    "hash": "a7c093bfe30839106af8edd471d63fada267e8b61fa88d91837ca95e7e60c575",
    "description": "Файл `iruby_service.hpp` содержит интерфейс `IRubyService` с чисто виртуальными функциями `execute_code` и `load_file`, которые выполняют код и загружают файл соответственно."
  },
  "src/interfaces/iwindow_service.hpp": {
    "modified_time": "2025-02-13 04:41:13 +0400",
    "hash": "fdec957bfb64b336364248e88f43d8684e59c1f0a1d4e3f8d06d332f6cd89f05",
    "description": "Файл `iwindow_service.hpp` содержит интерфейс `IWindowService` с методами:\n- `run()`: абстрактный метод без реализации.\nИнтерфейс предназначен для работы с окнами и несет обязанность запуска окна."
  },
  "src/main.cpp": {
    "modified_time": "2025-02-13 04:49:00 +0400",
    "hash": "8dae84b79bfcdec0606b11ee44804fc65f3a34d775d772dc43a00ef2a7948d25",
    "description": "Файл `main.cpp` содержит функцию `main`, которая создает объект `Container`, вызывает метод `configure` класса `AppModule` для конфигурации контейнера, затем получает сервис окон из контейнера и запускает его. В случае исключения выводит сообщение об ошибке."
  },
  "src/modules/app_module.cpp": {
    "modified_time": "2025-02-16 16:17:40 +0400",
    "hash": "6ea51b114e8efe8cedaa3cffc8229b990bfd889c557d73b5052a428c50524c5b",
    "description": "Файл `app_module.cpp` содержит реализацию метода `configure` класса `AppModule`. В методе происходит регистрация синглтонов `IRubyService` и `IWindowService` в контейнере. Для `IRubyService` создается экземпляр `RubyService`, а для `IWindowService` создается экземпляр `WindowService`, которому передается экземпляр `IRubyService`. Затем создаются два объекта `Label` для отображения ввода и результата на окне, и устанавливаются в `WindowService`."
  },
  "src/modules/app_module.hpp": {
    "modified_time": "2025-02-13 04:47:39 +0400",
    "hash": "38b5cdbad101341d87441714f54b0cac160f9b5f2a793c512fac4ffd34a9887b",
    "description": "Файл `app_module.hpp` содержит класс `AppModule` с одной статической функцией `configure`, которая принимает объект `Container` и выполняет конфигурацию."
  },
  "src/services/ruby_service.cpp": {
    "modified_time": "2025-02-13 04:46:04 +0400",
    "hash": "b62ed6428ef8dc223b59d2355e3650d53a8af2f2902e5c567a79d94f9bdf4d71",
    "description": "Файл `ruby_service.cpp` содержит класс `RubyService`, который предоставляет функциональность выполнения Ruby-кода. В конструкторе и деструкторе инициализируется и закрывается интерпретатор mruby. Метод `execute_code` выполняет переданный код, обрабатывает ошибки и возвращает результат выполнения. Метод `load_file` загружает код из файла и возвращает результат выполнения. Метод `handle_error` обрабатывает ошибки и возвращает сообщение об ошибке в виде строки."
  },
  "src/services/ruby_service.hpp": {
    "modified_time": "2025-02-13 04:45:34 +0400",
    "hash": "e4bcf0c44252b4d8668db874146ce241122d2db2d4e471729d3663d6510d980e",
    "description": "Файл `ruby_service.hpp` содержит класс `RubyService`, который реализует интерфейс `IRubyService`. В классе определены конструктор, деструктор, методы `execute_code` и `load_file` для выполнения кода и загрузки файла на языке Ruby. Также есть приватное поле `mrb` типа `mrb_state*` для работы с интерпретатором Ruby и метод `handle_error` для обработки ошибок."
  },
  "src/services/window_service.cpp": {
    "modified_time": "2025-02-16 23:17:36 +0400",
    "hash": "e0521a1049d3a4d6495290aa8841dddf6473c12ef827f67409b9959d8c28614e",
    "description": "Файл window_service.cpp содержит класс WindowService, который управляет окном X11. Класс имеет конструктор, деструктор, методы create_window, setup_gc, setup_xft, main_loop, redraw, handle_key_press, draw_at_pointer, addWidget, setInputLabel, setResultLabel, getDisplay, getWindow. Конструктор инициализирует окно, графический контекст и Xft. Метод run загружает Ruby-скрипт и запускает главный цикл. Методы redraw и handle_key_press обновляют содержимое окна в ответ на события. Метод draw_at_pointer рисует текст \"hi!\" по координатам указателя. Методы setInputLabel и setResultLabel устанавливают метки и регистрируют их как виджеты."
  },
  "src/services/window_service.hpp": {
    "modified_time": "2025-02-16 23:18:20 +0400",
    "hash": "2db269bf6bc779a5cf97e6985669a30e49f3244d9c96469e3221b52e0ca35b40",
    "description": "Файл window_service.hpp содержит класс WindowService, который реализует интерфейс IWindowService. Класс предоставляет методы для работы с окном X11, включая создание окна, настройку графического контекста, обработку событий клавиатуры и отрисовку компонентов. Класс также содержит методы для управления видимыми компонентами (виджетами) и установки меток ввода и вывода Ruby-результата."
  },
  "src/gui/buffered_component.cpp": {
    "modified_time": "2025-02-16 23:06:20 +0400",
    "hash": "65e72b55e05311449e3716359e501024ed8f1936674945b3a3c5951ff83afd77",
    "description": "Файл `buffered_component.cpp` содержит класс `BufferedComponent`, который является подклассом класса `VisibleComponent`. В конструкторе класса создается буферный pixmap с помощью функции `XCreatePixmap`. Метод `draw` отрисовывает содержимое буфера на указанном drawable, если флаг `needsRedraw_` установлен в true. Метод `invalidateBuffer` устанавливает флаг `needsRedraw_` в true, чтобы потребовать перерисовки. В деструкторе освобождается память, выделенная под буферный pixmap с помощью `XFreePixmap`."
  },
  "src/gui/buffered_component.hpp": {
    "modified_time": "2025-02-16 23:05:50 +0400",
    "hash": "0e657fd812dfb1164f98094f11954a4c2e18c7675981b49f1b7bd94af680fcec",
    "description": "Файл `buffered_component.hpp` содержит класс `BufferedComponent`, который является наследником класса `VisibleComponent`. В конструкторе принимаются параметры `display`, `window`, `gc`, `width` и `height`. Класс имеет метод `draw`, который вызывает виртуальную функцию `drawOnBuffer` для рисования на внутреннем буфере. Также есть метод `invalidateBuffer`, который вызывается для обновления внутреннего буфера. Внутренний буфер представлен переменной `buffer_`, а флаг `needsRedraw_` указывает на необходимость перерисовки."
  },
  "src/gui/label.cpp": {
    "modified_time": "2025-02-16 23:08:31 +0400",
    "hash": "f26782e55c492f893bb61fcb9e0acf64a04bbf643f82997367f659c6528e35f9",
    "description": "Файл `label.cpp` содержит класс `Label`, который представляет собой надпись с определенным текстом, шрифтом и цветом. Класс наследуется от `BufferedComponent` и имеет конструктор для инициализации параметров надписи, а также методы для отрисовки текста на буфере. В конструкторе происходит загрузка шрифта и выделение цвета, а также создание GC для очистки буфера. Метод `drawOnBuffer` очищает буфер, рисует текст с заданным шрифтом и цветом, используя Xft. В деструкторе освобождаются ресурсы, такие как цвет, шрифт и GC."
  },
  "src/gui/label.hpp": {
    "modified_time": "2025-02-16 23:15:42 +0400",
    "hash": "c72df2b1965aa4d137dd82f09df287d61a1cf052681e856e52fc8a3bdd536f32",
    "description": "Файл `label.hpp` содержит класс `Label`, который является наследником класса `BufferedComponent`. Основные атрибуты класса: `x_`, `y_`, `text_`, `font_`, `color_`. Конструктор принимает параметры для инициализации компонента, такие как текст, шрифт и цвет. Метод `setText` устанавливает новый текст для отображения на метке и вызывает `invalidateBuffer` для обновления буфера. Метод `drawOnBuffer` отвечает за отрисовку текста на буфере."
  },
  "src/gui/visible_component.hpp": {
    "modified_time": "2025-02-16 16:10:44 +0400",
    "hash": "dec99b490fefb17b66e1db1b7e73c2007494f535415e64475102426c2f0d7a74",
    "description": "Файл `visible_component.hpp` содержит класс `VisibleComponent`, который представляет видимый компонент интерфейса. Класс имеет конструктор для инициализации параметров компонента и виртуальный метод `draw`, который отвечает за отрисовку компонента на заданном drawable. Основные члены класса: `display_` (дисплей), `window_` (окно), `gc_` (графический контекст), `width_` и `height_` (ширина и высота компонента)."
  }
}